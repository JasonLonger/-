## ✨数组是存放在连续内存空间上的相同类型数据的集合
![impicture_20230816_094725](https://github.com/JasonLonger/note/assets/50047690/5079aa97-a8c0-409f-a3d5-1e8714515ead)

👏数组下标都是从0开始的。

👏数组内存空间的地址是连续的

👏正是因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。

👏数组的元素是不能删的，只能覆盖


## ✨二分查找
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
![impicture_20230821_204955](https://github.com/JasonLonger/note/assets/50047690/1bf1f199-9ee0-472c-8111-6f61b5729051)

👏前提：数组为有序数组，同时题目还强调数组中无重复元素

👏需要注意的点可能是边界问题，[left, right]还是[left, right)，进而导致判断的不同

#### 🔥方法1：[left, right]情况

👏while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=

👏if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1
```
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
时间复杂度：O(log n)
空间复杂度：O(1)

var search = function(nums, target) {
    // right是数组最后一个数的下标，num[right]在查找范围内，是左闭右闭区间
    let mid, left = 0, right = nums.length - 1;
    // 当left=right时，由于nums[right]在查找范围内，所以要包括此情况
    while (left <= right) {
        // 位运算 + 防止大数溢出
        mid = left + ((right - left) >> 1);
        // 如果中间数大于目标值，要把中间数排除查找范围，所以右边界更新为mid-1；如果右边界更新为mid，那中间数还在下次查找范围内
        if (nums[mid] > target) {
            right = mid - 1;  // 去左面闭区间寻找
        } else if (nums[mid] < target) {
            left = mid + 1;   // 去右面闭区间寻找
        } else {
            return mid;
        }
    }
    return -1;
};
```
#### 🔥方法1：[left, right)情况

👏while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的

👏if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]
```
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
时间复杂度：O(log n)
空间复杂度：O(1)

var search = function(nums, target) {
    // right是数组最后一个数的下标+1，nums[right]不在查找范围内，是左闭右开区间
    let mid, left = 0, right = nums.length;    
    // 当left=right时，由于nums[right]不在查找范围，所以不必包括此情况
    while (left < right) {
        // 位运算 + 防止大数溢出
        mid = left + ((right - left) >> 1);
        // 如果中间值大于目标值，中间值不应在下次查找的范围内，但中间值的前一个值应在；
        // 由于right本来就不在查找范围内，所以将右边界更新为中间值，如果更新右边界为mid-1则将中间值的前一个值也踢出了下次寻找范围
        if (nums[mid] > target) {
            right = mid;  // 去左区间寻找
        } else if (nums[mid] < target) {
            left = mid + 1;   // 去右区间寻找
        } else {
            return mid;
        }
    }
    return -1;
};
```

#### 怎么看出二分查找时间复杂度是log N ？
在二分查找算法中，时间复杂度为 O(log n) 的原因可以从算法的每一步操作来理解。以下是如何看出二分查找算法的时间复杂度为 O(log n) 的解释：

👏1. 每一步减半搜索空间： 在二分查找中，每一步都将搜索空间减半。假设开始时搜索范围包含 n 个元素，第一步减少到 n/2，第二步减少到 n/4，以此类推。总共需要 k 步将搜索空间减小到 1（最坏情况下），其中 n / 2^k = 1。解这个方程可以得到 k = log₂(n)。因此，算法最多需要 log₂(n) 步才能找到目标元素或确定目标元素不存在。
   
2. 对数时间复杂度： 由于算法在每一步都将搜索范围减半，所以总共需要 log₂(n) 步才能完成整个搜索过程。每一步的时间复杂度是常数级别的，因此总体时间复杂度为 O(log n)。
   
3. 以 2 为底的对数： 通常情况下，在二分查找中，底数是 2，因为每一步都将搜索范围减半。因此，算法的时间复杂度表示为 O(log₂(n))。
   
总之，二分查找算法之所以具有 O(log n) 的时间复杂度，是因为每一步操作都将搜索范围减半，导致算法在输入规模 n 增大时，运行时间以以 2 为底的对数速度增长。这使得二分查找成为一种高效的查找算法，特别适用于有序数据集。


## ✨双指针法

通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。

👏快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组

👏慢指针：指向更新 新数组下标的位置

#### 题目：移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。

示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

```

```

